#!/usr/bin/env nft -f

table inet sfw {
	include "./conf.def"

	set private-net4 {
		type ipv4_addr
		flags constant,interval
		elements = $SET_PRIVATE_NETS_V4
	}

	set private-net6 {
		type ipv6_addr
		flags constant,interval
		elements = $SET_PRIVATE_NETS_V6
	}

	# invalid packets
	counter invalid-pkts { packets 0 bytes 0 }
	# !(tcp|udp) protocol packets dropped
	counter catchall { packets 0 bytes 0 }
	# iifgroup != IIFGROUP_ETHERNET | IIFGROUP_VPN
	counter iif-other { packets 0 bytes 0 }
	# non-unicast
	counter non-unicast { packets 0 bytes 0 }
	# no reverse path
	counter no-reverse-path { packets 0 bytes 0 }


	chain iif-dispatch {
		type filter hook input priority filter; policy drop;
		iif "lo" accept
		jump ct-state-filter
		iifgroup $IIFGROUP_ETHERNET goto trampoline
		iifgroup $IIFGROUP_VPN goto vpn

		# basic filtering of unhandled iifgroups
		counter name "iif-other" jump icmpx-filter
		goto reject-verdict
	}

	chain trampoline {
		ip saddr @private-net4 jump private
		ip6 saddr @private-net6 jump private
		jump public
		jump icmpx-filter
		goto reject-verdict
	}

	chain reject-verdict {
		meta l4proto udp reject
		meta l4proto tcp reject with tcp reset
		counter name "catchall" reject with icmpx type port-unreachable
		# end of matching
	}

	chain icmpx-filter {
		ip protocol icmp accept
		ip protocol igmp accept
		ip6 nexthdr ipv6-icmp accept
		jump non-unicast-filter
	}

	chain non-unicast-filter {
		# silently drop unsolicited broadcast/multicast
		meta pkttype { broadcast, multicast } counter name "non-unicast" drop
	}

	chain ct-state-filter {
		# stateful filtering
		ct state established,related accept
		ct state invalid counter name "invalid-pkts" drop
	}

	chain rp-filter {
		# reverse path filter for ipv6
		type filter hook prerouting priority raw; policy drop;
		fib saddr . iif oif exists accept
		counter name "no-reverse-path"
	}

	include "./zones/vpn.nft"
	include "./zones/private.nft"
	include "./zones/public.nft"
	include "./zones/output.nft"
	include "./zones/forward.nft"
}
